import os
import sys
import shutil
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox
import re
import time

# --- CONFIGURATION ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if getattr(sys, 'frozen', False):
    SCRIPT_DIR = os.path.dirname(sys.executable)

DIRECTORIES_FOLDER = os.path.join(SCRIPT_DIR, "Directories")
SAVES_FOLDER = os.path.join(SCRIPT_DIR, "SAVES")
LOCATIONS_FILE = os.path.join(DIRECTORIES_FOLDER, "locations.bat")

os.makedirs(DIRECTORIES_FOLDER, exist_ok=True)
os.makedirs(SAVES_FOLDER, exist_ok=True)

# --- UTILITIES ---

def is_junction(path):
    try:
        return bool(os.lstat(path).st_file_attributes & 1024)
    except OSError:
        return False

def robust_copy(source, destination):
    cmd = ["robocopy", source, destination, "/E", "/COPY:DAT", "/R:3", "/W:2"]
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.returncode < 8

def create_mega_ignore(target_folder):
    ignore_path = os.path.join(target_folder, ".megaignore")
    if not os.path.exists(ignore_path):
        try:
            with open(ignore_path, "w") as f:
                f.write("# Generated by Save Manager to prevent sync loops\n")
        except: pass

def make_path_dynamic(path):
    """Converts C:\Users\Denis\... to %USERPROFILE%\..."""
    user_profile = os.environ['USERPROFILE']
    # Case-insensitive check
    if path.lower().startswith(user_profile.lower()):
        return f"%USERPROFILE%{path[len(user_profile):]}"
    return path

def create_location_txt(target_folder, original_path):
    """Creates Location.txt using the PORTABLE (%USERPROFILE%) syntax."""
    loc_file = os.path.join(target_folder, "Location.txt")
    
    # FORCE DYNAMIC PATH before writing
    final_path = make_path_dynamic(original_path)
    
    try:
        with open(loc_file, "w") as f:
            f.write(f"Original Location:\n{final_path}")
    except Exception as e:
        print(f"Warning: Could not write Location.txt: {e}")

def append_to_locations(cmd):
    if not os.path.exists(LOCATIONS_FILE):
        with open(LOCATIONS_FILE, 'w') as f: f.write("@echo off\n")
    with open(LOCATIONS_FILE, 'r') as f: content = f.read()
    if cmd.strip() not in content:
        with open(LOCATIONS_FILE, 'a') as f: f.write(f"{cmd}\n")

# --- MIGRATION ---

def action_migrate_folder():
    root = tk.Tk()
    root.withdraw()
    
    original_path = filedialog.askdirectory(title="Select Save Folder")
    if not original_path: return
    
    original_path = os.path.normpath(original_path)
    folder_name = os.path.basename(original_path)
    cloud_target = os.path.join(SAVES_FOLDER, folder_name)

    if not os.path.exists(original_path):
        messagebox.showerror("Error", "Folder does not exist.")
        return
    if is_junction(original_path):
        messagebox.showinfo("Info", "Already a junction.")
        return
    if os.path.exists(cloud_target):
        messagebox.showerror("Collision", "Folder exists in Cloud.")
        return

    print(f"--- Migrating: {folder_name} ---")
    if not robust_copy(original_path, cloud_target):
        messagebox.showerror("Error", "Copy failed.")
        if os.path.exists(cloud_target): shutil.rmtree(cloud_target)
        return

    # Create Metadata (Now uses Dynamic Path)
    create_location_txt(cloud_target, original_path)
    create_mega_ignore(cloud_target)

    backup_path = original_path + "_BACKUP_TEMP"
    try:
        os.rename(original_path, backup_path)
    except OSError as e:
        messagebox.showerror("Error", f"Rename failed: {e}")
        shutil.rmtree(cloud_target)
        return

    # Use Dynamic path for batch, Real path for immediate execution
    dynamic_path = make_path_dynamic(original_path)
    batch_cmd = f'mklink /J "{dynamic_path}" "{cloud_target}"'
    real_cmd = f'mklink /J "{original_path}" "{cloud_target}"'

    try:
        subprocess.run(f'cmd /c {real_cmd}', check=True, shell=True)
        append_to_locations(batch_cmd)
    except subprocess.CalledProcessError:
        print("Rollback...")
        os.rename(backup_path, original_path)
        return

    try:
        shutil.rmtree(backup_path)
        messagebox.showinfo("Success", f"Migrated!\nLocation: {cloud_target}")
    except:
        messagebox.showwarning("Warning", f"Delete backup manually:\n{backup_path}")

# --- REPAIR ---

def action_repair_links():
    if not os.path.exists(LOCATIONS_FILE):
        messagebox.showinfo("Info", "No locations.bat found.")
        return

    print("--- Dynamic Maintenance ---")
    with open(LOCATIONS_FILE, 'r') as f: lines = f.readlines()

    refreshed, collisions = 0, 0
    pattern = re.compile(r'mklink\s+/J\s+"([^"]+)"\s+"([^"]+)"', re.IGNORECASE)

    for line in lines:
        match = pattern.search(line)
        if match:
            raw_link, raw_target = match.groups()
            
            # Resolve %USERPROFILE% for current machine
            link_path = os.path.expandvars(raw_link)
            target_path = os.path.expandvars(raw_target)
            folder_name = os.path.basename(link_path)

            if not os.path.exists(target_path): continue
            
            print(f"Checking: {folder_name}...")
            
            if os.path.lexists(link_path):
                if is_junction(link_path):
                    try: os.rmdir(link_path)
                    except: pass
                elif os.path.isdir(link_path):
                    if not os.listdir(link_path):
                        try: os.rmdir(link_path)
                        except: pass
                    else:
                        os.rename(link_path, f"{link_path}_BAK_{int(time.time())}")
                        collisions += 1

            try:
                subprocess.run(f'cmd /c mklink /J "{link_path}" "{target_path}"', shell=True, check=True, capture_output=True)
                refreshed += 1
            except: pass

    messagebox.showinfo("Report", f"Links Refreshed: {refreshed}\nCollisions Backed Up: {collisions}")

# --- MAIN ---

def main():
    root = tk.Tk()
    root.title("Save Manager v5.1")
    w, h = 300, 150
    ws, hs = root.winfo_screenwidth(), root.winfo_screenheight()
    root.geometry(f'{w}x{h}+{int((ws/2)-(w/2))}+{int((hs/2)-(h/2))}')
    
    tk.Label(root, text="Select Operation:", font=("Arial", 10, "bold")).pack(pady=10)
    tk.Button(root, text="Migrate New Save", width=20, command=action_migrate_folder).pack(pady=5)
    tk.Button(root, text="Repair / Refresh Links", width=20, command=action_repair_links).pack(pady=5)
    root.mainloop()

if __name__ == "__main__":
    main()
